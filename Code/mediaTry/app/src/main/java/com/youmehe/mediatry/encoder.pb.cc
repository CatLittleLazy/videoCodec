// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: encoder.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "encoder.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* Encoders_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Encoders_reflection_ = NULL;
const ::google::protobuf::Descriptor* Encoders_alias_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Encoders_alias_reflection_ = NULL;
const ::google::protobuf::Descriptor* Encoders_limit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Encoders_limit_reflection_ = NULL;
const ::google::protobuf::Descriptor* Encoders_mediaCodec_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Encoders_mediaCodec_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_encoder_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_encoder_2eproto() {
  protobuf_AddDesc_encoder_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "encoder.proto");
  GOOGLE_CHECK(file != NULL);
  Encoders_descriptor_ = file->message_type(0);
  static const int Encoders_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders, mediacodec_),
  };
  Encoders_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Encoders_descriptor_,
      Encoders::internal_default_instance(),
      Encoders_offsets_,
      -1,
      -1,
      -1,
      sizeof(Encoders),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders, _internal_metadata_));
  Encoders_alias_descriptor_ = Encoders_descriptor_->nested_type(0);
  static const int Encoders_alias_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders_alias, name_),
  };
  Encoders_alias_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Encoders_alias_descriptor_,
      Encoders_alias::internal_default_instance(),
      Encoders_alias_offsets_,
      -1,
      -1,
      -1,
      sizeof(Encoders_alias),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders_alias, _internal_metadata_));
  Encoders_limit_descriptor_ = Encoders_descriptor_->nested_type(1);
  static const int Encoders_limit_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders_limit, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders_limit, min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders_limit, max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders_limit, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders_limit, range_),
  };
  Encoders_limit_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Encoders_limit_descriptor_,
      Encoders_limit::internal_default_instance(),
      Encoders_limit_offsets_,
      -1,
      -1,
      -1,
      sizeof(Encoders_limit),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders_limit, _internal_metadata_));
  Encoders_mediaCodec_descriptor_ = Encoders_descriptor_->nested_type(2);
  static const int Encoders_mediaCodec_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders_mediaCodec, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders_mediaCodec, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders_mediaCodec, alias_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders_mediaCodec, limit_),
  };
  Encoders_mediaCodec_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Encoders_mediaCodec_descriptor_,
      Encoders_mediaCodec::internal_default_instance(),
      Encoders_mediaCodec_offsets_,
      -1,
      -1,
      -1,
      sizeof(Encoders_mediaCodec),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Encoders_mediaCodec, _internal_metadata_));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_encoder_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Encoders_descriptor_, Encoders::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Encoders_alias_descriptor_, Encoders_alias::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Encoders_limit_descriptor_, Encoders_limit::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Encoders_mediaCodec_descriptor_, Encoders_mediaCodec::internal_default_instance());
}

}  // namespace

void protobuf_ShutdownFile_encoder_2eproto() {
  Encoders_default_instance_.Shutdown();
  delete Encoders_reflection_;
  Encoders_alias_default_instance_.Shutdown();
  delete Encoders_alias_reflection_;
  Encoders_limit_default_instance_.Shutdown();
  delete Encoders_limit_reflection_;
  Encoders_mediaCodec_default_instance_.Shutdown();
  delete Encoders_mediaCodec_reflection_;
}

void protobuf_InitDefaults_encoder_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  Encoders_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  Encoders_alias_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  Encoders_limit_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  Encoders_mediaCodec_default_instance_.DefaultConstruct();
  Encoders_default_instance_.get_mutable()->InitAsDefaultInstance();
  Encoders_alias_default_instance_.get_mutable()->InitAsDefaultInstance();
  Encoders_limit_default_instance_.get_mutable()->InitAsDefaultInstance();
  Encoders_mediaCodec_default_instance_.get_mutable()->InitAsDefaultInstance();
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_InitDefaults_encoder_2eproto_once_);
void protobuf_InitDefaults_encoder_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_InitDefaults_encoder_2eproto_once_,
                 &protobuf_InitDefaults_encoder_2eproto_impl);
}
void protobuf_AddDesc_encoder_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  protobuf_InitDefaults_encoder_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rencoder.proto\"\204\002\n\010Encoders\022(\n\nMediaCod"
    "ec\030\001 \003(\0132\024.Encoders.mediaCodec\032\025\n\005alias\022"
    "\014\n\004name\030\001 \001(\t\032M\n\005limit\022\014\n\004name\030\001 \001(\t\022\013\n\003"
    "min\030\002 \001(\t\022\013\n\003max\030\003 \001(\t\022\r\n\005value\030\004 \001(\t\022\r\n"
    "\005range\030\005 \001(\t\032h\n\nmediaCodec\022\014\n\004name\030\001 \001(\t"
    "\022\014\n\004type\030\002 \001(\t\022\036\n\005Alias\030\003 \001(\0132\017.Encoders"
    ".alias\022\036\n\005Limit\030\004 \003(\0132\017.Encoders.limitB#"
    "\n\024com.youmehe.mediatryB\013WytEncodersb\006pro"
    "to3", 323);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "encoder.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_encoder_2eproto);
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_encoder_2eproto_once_);
void protobuf_AddDesc_encoder_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_encoder_2eproto_once_,
                 &protobuf_AddDesc_encoder_2eproto_impl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_encoder_2eproto {
  StaticDescriptorInitializer_encoder_2eproto() {
    protobuf_AddDesc_encoder_2eproto();
  }
} static_descriptor_initializer_encoder_2eproto_;

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD GOOGLE_ATTRIBUTE_NORETURN;
static void MergeFromFail(int line) {
  ::google::protobuf::internal::MergeFromFail(__FILE__, line);
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Encoders_alias::kNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Encoders_alias::Encoders_alias()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_encoder_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:Encoders.alias)
}

void Encoders_alias::InitAsDefaultInstance() {
}

Encoders_alias::Encoders_alias(const Encoders_alias& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Encoders.alias)
}

void Encoders_alias::SharedCtor() {
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

Encoders_alias::~Encoders_alias() {
  // @@protoc_insertion_point(destructor:Encoders.alias)
  SharedDtor();
}

void Encoders_alias::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Encoders_alias::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Encoders_alias::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Encoders_alias_descriptor_;
}

const Encoders_alias& Encoders_alias::default_instance() {
  protobuf_InitDefaults_encoder_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Encoders_alias> Encoders_alias_default_instance_;

Encoders_alias* Encoders_alias::New(::google::protobuf::Arena* arena) const {
  Encoders_alias* n = new Encoders_alias;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Encoders_alias::Clear() {
// @@protoc_insertion_point(message_clear_start:Encoders.alias)
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Encoders_alias::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Encoders.alias)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Encoders.alias.name"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Encoders.alias)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Encoders.alias)
  return false;
#undef DO_
}

void Encoders_alias::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Encoders.alias)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.alias.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // @@protoc_insertion_point(serialize_end:Encoders.alias)
}

::google::protobuf::uint8* Encoders_alias::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Encoders.alias)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.alias.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Encoders.alias)
  return target;
}

size_t Encoders_alias::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Encoders.alias)
  size_t total_size = 0;

  // optional string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Encoders_alias::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Encoders.alias)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Encoders_alias* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Encoders_alias>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Encoders.alias)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Encoders.alias)
    UnsafeMergeFrom(*source);
  }
}

void Encoders_alias::MergeFrom(const Encoders_alias& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Encoders.alias)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Encoders_alias::UnsafeMergeFrom(const Encoders_alias& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
}

void Encoders_alias::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Encoders.alias)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Encoders_alias::CopyFrom(const Encoders_alias& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Encoders.alias)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Encoders_alias::IsInitialized() const {

  return true;
}

void Encoders_alias::Swap(Encoders_alias* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Encoders_alias::InternalSwap(Encoders_alias* other) {
  name_.Swap(&other->name_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Encoders_alias::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Encoders_alias_descriptor_;
  metadata.reflection = Encoders_alias_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Encoders_limit::kNameFieldNumber;
const int Encoders_limit::kMinFieldNumber;
const int Encoders_limit::kMaxFieldNumber;
const int Encoders_limit::kValueFieldNumber;
const int Encoders_limit::kRangeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Encoders_limit::Encoders_limit()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_encoder_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:Encoders.limit)
}

void Encoders_limit::InitAsDefaultInstance() {
}

Encoders_limit::Encoders_limit(const Encoders_limit& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Encoders.limit)
}

void Encoders_limit::SharedCtor() {
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  min_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  max_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  range_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

Encoders_limit::~Encoders_limit() {
  // @@protoc_insertion_point(destructor:Encoders.limit)
  SharedDtor();
}

void Encoders_limit::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  min_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  max_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  range_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Encoders_limit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Encoders_limit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Encoders_limit_descriptor_;
}

const Encoders_limit& Encoders_limit::default_instance() {
  protobuf_InitDefaults_encoder_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Encoders_limit> Encoders_limit_default_instance_;

Encoders_limit* Encoders_limit::New(::google::protobuf::Arena* arena) const {
  Encoders_limit* n = new Encoders_limit;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Encoders_limit::Clear() {
// @@protoc_insertion_point(message_clear_start:Encoders.limit)
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  min_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  max_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  range_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Encoders_limit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Encoders.limit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Encoders.limit.name"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_min;
        break;
      }

      // optional string min = 2;
      case 2: {
        if (tag == 18) {
         parse_min:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_min()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->min().data(), this->min().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Encoders.limit.min"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_max;
        break;
      }

      // optional string max = 3;
      case 3: {
        if (tag == 26) {
         parse_max:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_max()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->max().data(), this->max().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Encoders.limit.max"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_value;
        break;
      }

      // optional string value = 4;
      case 4: {
        if (tag == 34) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Encoders.limit.value"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_range;
        break;
      }

      // optional string range = 5;
      case 5: {
        if (tag == 42) {
         parse_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_range()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->range().data(), this->range().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Encoders.limit.range"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Encoders.limit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Encoders.limit)
  return false;
#undef DO_
}

void Encoders_limit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Encoders.limit)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.limit.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string min = 2;
  if (this->min().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->min().data(), this->min().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.limit.min");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->min(), output);
  }

  // optional string max = 3;
  if (this->max().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->max().data(), this->max().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.limit.max");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->max(), output);
  }

  // optional string value = 4;
  if (this->value().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.limit.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->value(), output);
  }

  // optional string range = 5;
  if (this->range().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->range().data(), this->range().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.limit.range");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->range(), output);
  }

  // @@protoc_insertion_point(serialize_end:Encoders.limit)
}

::google::protobuf::uint8* Encoders_limit::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Encoders.limit)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.limit.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string min = 2;
  if (this->min().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->min().data(), this->min().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.limit.min");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->min(), target);
  }

  // optional string max = 3;
  if (this->max().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->max().data(), this->max().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.limit.max");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->max(), target);
  }

  // optional string value = 4;
  if (this->value().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.limit.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->value(), target);
  }

  // optional string range = 5;
  if (this->range().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->range().data(), this->range().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.limit.range");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->range(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Encoders.limit)
  return target;
}

size_t Encoders_limit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Encoders.limit)
  size_t total_size = 0;

  // optional string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // optional string min = 2;
  if (this->min().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->min());
  }

  // optional string max = 3;
  if (this->max().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->max());
  }

  // optional string value = 4;
  if (this->value().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }

  // optional string range = 5;
  if (this->range().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->range());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Encoders_limit::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Encoders.limit)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Encoders_limit* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Encoders_limit>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Encoders.limit)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Encoders.limit)
    UnsafeMergeFrom(*source);
  }
}

void Encoders_limit::MergeFrom(const Encoders_limit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Encoders.limit)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Encoders_limit::UnsafeMergeFrom(const Encoders_limit& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.min().size() > 0) {

    min_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.min_);
  }
  if (from.max().size() > 0) {

    max_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.max_);
  }
  if (from.value().size() > 0) {

    value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
  }
  if (from.range().size() > 0) {

    range_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.range_);
  }
}

void Encoders_limit::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Encoders.limit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Encoders_limit::CopyFrom(const Encoders_limit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Encoders.limit)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Encoders_limit::IsInitialized() const {

  return true;
}

void Encoders_limit::Swap(Encoders_limit* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Encoders_limit::InternalSwap(Encoders_limit* other) {
  name_.Swap(&other->name_);
  min_.Swap(&other->min_);
  max_.Swap(&other->max_);
  value_.Swap(&other->value_);
  range_.Swap(&other->range_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Encoders_limit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Encoders_limit_descriptor_;
  metadata.reflection = Encoders_limit_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Encoders_mediaCodec::kNameFieldNumber;
const int Encoders_mediaCodec::kTypeFieldNumber;
const int Encoders_mediaCodec::kAliasFieldNumber;
const int Encoders_mediaCodec::kLimitFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Encoders_mediaCodec::Encoders_mediaCodec()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_encoder_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:Encoders.mediaCodec)
}

void Encoders_mediaCodec::InitAsDefaultInstance() {
  alias_ = const_cast< ::Encoders_alias*>(
      ::Encoders_alias::internal_default_instance());
}

Encoders_mediaCodec::Encoders_mediaCodec(const Encoders_mediaCodec& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Encoders.mediaCodec)
}

void Encoders_mediaCodec::SharedCtor() {
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  alias_ = NULL;
  _cached_size_ = 0;
}

Encoders_mediaCodec::~Encoders_mediaCodec() {
  // @@protoc_insertion_point(destructor:Encoders.mediaCodec)
  SharedDtor();
}

void Encoders_mediaCodec::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != &Encoders_mediaCodec_default_instance_.get()) {
    delete alias_;
  }
}

void Encoders_mediaCodec::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Encoders_mediaCodec::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Encoders_mediaCodec_descriptor_;
}

const Encoders_mediaCodec& Encoders_mediaCodec::default_instance() {
  protobuf_InitDefaults_encoder_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Encoders_mediaCodec> Encoders_mediaCodec_default_instance_;

Encoders_mediaCodec* Encoders_mediaCodec::New(::google::protobuf::Arena* arena) const {
  Encoders_mediaCodec* n = new Encoders_mediaCodec;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Encoders_mediaCodec::Clear() {
// @@protoc_insertion_point(message_clear_start:Encoders.mediaCodec)
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && alias_ != NULL) delete alias_;
  alias_ = NULL;
  limit_.Clear();
}

bool Encoders_mediaCodec::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Encoders.mediaCodec)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Encoders.mediaCodec.name"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_type;
        break;
      }

      // optional string type = 2;
      case 2: {
        if (tag == 18) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Encoders.mediaCodec.type"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_Alias;
        break;
      }

      // optional .Encoders.alias Alias = 3;
      case 3: {
        if (tag == 26) {
         parse_Alias:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_alias()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_Limit;
        break;
      }

      // repeated .Encoders.limit Limit = 4;
      case 4: {
        if (tag == 34) {
         parse_Limit:
          DO_(input->IncrementRecursionDepth());
         parse_loop_Limit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_limit()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_Limit;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Encoders.mediaCodec)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Encoders.mediaCodec)
  return false;
#undef DO_
}

void Encoders_mediaCodec::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Encoders.mediaCodec)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.mediaCodec.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string type = 2;
  if (this->type().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.mediaCodec.type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->type(), output);
  }

  // optional .Encoders.alias Alias = 3;
  if (this->has_alias()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->alias_, output);
  }

  // repeated .Encoders.limit Limit = 4;
  for (unsigned int i = 0, n = this->limit_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->limit(i), output);
  }

  // @@protoc_insertion_point(serialize_end:Encoders.mediaCodec)
}

::google::protobuf::uint8* Encoders_mediaCodec::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Encoders.mediaCodec)
  // optional string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.mediaCodec.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string type = 2;
  if (this->type().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Encoders.mediaCodec.type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->type(), target);
  }

  // optional .Encoders.alias Alias = 3;
  if (this->has_alias()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->alias_, false, target);
  }

  // repeated .Encoders.limit Limit = 4;
  for (unsigned int i = 0, n = this->limit_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, this->limit(i), false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Encoders.mediaCodec)
  return target;
}

size_t Encoders_mediaCodec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Encoders.mediaCodec)
  size_t total_size = 0;

  // optional string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // optional string type = 2;
  if (this->type().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->type());
  }

  // optional .Encoders.alias Alias = 3;
  if (this->has_alias()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->alias_);
  }

  // repeated .Encoders.limit Limit = 4;
  {
    unsigned int count = this->limit_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->limit(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Encoders_mediaCodec::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Encoders.mediaCodec)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Encoders_mediaCodec* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Encoders_mediaCodec>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Encoders.mediaCodec)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Encoders.mediaCodec)
    UnsafeMergeFrom(*source);
  }
}

void Encoders_mediaCodec::MergeFrom(const Encoders_mediaCodec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Encoders.mediaCodec)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Encoders_mediaCodec::UnsafeMergeFrom(const Encoders_mediaCodec& from) {
  GOOGLE_DCHECK(&from != this);
  limit_.MergeFrom(from.limit_);
  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.type().size() > 0) {

    type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
  }
  if (from.has_alias()) {
    mutable_alias()->::Encoders_alias::MergeFrom(from.alias());
  }
}

void Encoders_mediaCodec::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Encoders.mediaCodec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Encoders_mediaCodec::CopyFrom(const Encoders_mediaCodec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Encoders.mediaCodec)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Encoders_mediaCodec::IsInitialized() const {

  return true;
}

void Encoders_mediaCodec::Swap(Encoders_mediaCodec* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Encoders_mediaCodec::InternalSwap(Encoders_mediaCodec* other) {
  name_.Swap(&other->name_);
  type_.Swap(&other->type_);
  std::swap(alias_, other->alias_);
  limit_.UnsafeArenaSwap(&other->limit_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Encoders_mediaCodec::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Encoders_mediaCodec_descriptor_;
  metadata.reflection = Encoders_mediaCodec_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Encoders::kMediaCodecFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Encoders::Encoders()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_encoder_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:Encoders)
}

void Encoders::InitAsDefaultInstance() {
}

Encoders::Encoders(const Encoders& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Encoders)
}

void Encoders::SharedCtor() {
  _cached_size_ = 0;
}

Encoders::~Encoders() {
  // @@protoc_insertion_point(destructor:Encoders)
  SharedDtor();
}

void Encoders::SharedDtor() {
}

void Encoders::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Encoders::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Encoders_descriptor_;
}

const Encoders& Encoders::default_instance() {
  protobuf_InitDefaults_encoder_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Encoders> Encoders_default_instance_;

Encoders* Encoders::New(::google::protobuf::Arena* arena) const {
  Encoders* n = new Encoders;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Encoders::Clear() {
// @@protoc_insertion_point(message_clear_start:Encoders)
  mediacodec_.Clear();
}

bool Encoders::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Encoders)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Encoders.mediaCodec MediaCodec = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_MediaCodec:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_mediacodec()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_MediaCodec;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Encoders)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Encoders)
  return false;
#undef DO_
}

void Encoders::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Encoders)
  // repeated .Encoders.mediaCodec MediaCodec = 1;
  for (unsigned int i = 0, n = this->mediacodec_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->mediacodec(i), output);
  }

  // @@protoc_insertion_point(serialize_end:Encoders)
}

::google::protobuf::uint8* Encoders::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Encoders)
  // repeated .Encoders.mediaCodec MediaCodec = 1;
  for (unsigned int i = 0, n = this->mediacodec_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->mediacodec(i), false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Encoders)
  return target;
}

size_t Encoders::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Encoders)
  size_t total_size = 0;

  // repeated .Encoders.mediaCodec MediaCodec = 1;
  {
    unsigned int count = this->mediacodec_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mediacodec(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Encoders::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Encoders)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Encoders* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Encoders>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Encoders)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Encoders)
    UnsafeMergeFrom(*source);
  }
}

void Encoders::MergeFrom(const Encoders& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Encoders)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Encoders::UnsafeMergeFrom(const Encoders& from) {
  GOOGLE_DCHECK(&from != this);
  mediacodec_.MergeFrom(from.mediacodec_);
}

void Encoders::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Encoders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Encoders::CopyFrom(const Encoders& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Encoders)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Encoders::IsInitialized() const {

  return true;
}

void Encoders::Swap(Encoders* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Encoders::InternalSwap(Encoders* other) {
  mediacodec_.UnsafeArenaSwap(&other->mediacodec_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Encoders::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Encoders_descriptor_;
  metadata.reflection = Encoders_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Encoders_alias

// optional string name = 1;
void Encoders_alias::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Encoders_alias::name() const {
  // @@protoc_insertion_point(field_get:Encoders.alias.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_alias::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Encoders.alias.name)
}
void Encoders_alias::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Encoders.alias.name)
}
void Encoders_alias::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Encoders.alias.name)
}
::std::string* Encoders_alias::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Encoders.alias.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Encoders_alias::release_name() {
  // @@protoc_insertion_point(field_release:Encoders.alias.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_alias::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Encoders.alias.name)
}

inline const Encoders_alias* Encoders_alias::internal_default_instance() {
  return &Encoders_alias_default_instance_.get();
}
// -------------------------------------------------------------------

// Encoders_limit

// optional string name = 1;
void Encoders_limit::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Encoders_limit::name() const {
  // @@protoc_insertion_point(field_get:Encoders.limit.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_limit::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Encoders.limit.name)
}
void Encoders_limit::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Encoders.limit.name)
}
void Encoders_limit::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Encoders.limit.name)
}
::std::string* Encoders_limit::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Encoders.limit.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Encoders_limit::release_name() {
  // @@protoc_insertion_point(field_release:Encoders.limit.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_limit::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Encoders.limit.name)
}

// optional string min = 2;
void Encoders_limit::clear_min() {
  min_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Encoders_limit::min() const {
  // @@protoc_insertion_point(field_get:Encoders.limit.min)
  return min_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_limit::set_min(const ::std::string& value) {
  
  min_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Encoders.limit.min)
}
void Encoders_limit::set_min(const char* value) {
  
  min_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Encoders.limit.min)
}
void Encoders_limit::set_min(const char* value, size_t size) {
  
  min_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Encoders.limit.min)
}
::std::string* Encoders_limit::mutable_min() {
  
  // @@protoc_insertion_point(field_mutable:Encoders.limit.min)
  return min_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Encoders_limit::release_min() {
  // @@protoc_insertion_point(field_release:Encoders.limit.min)
  
  return min_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_limit::set_allocated_min(::std::string* min) {
  if (min != NULL) {
    
  } else {
    
  }
  min_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), min);
  // @@protoc_insertion_point(field_set_allocated:Encoders.limit.min)
}

// optional string max = 3;
void Encoders_limit::clear_max() {
  max_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Encoders_limit::max() const {
  // @@protoc_insertion_point(field_get:Encoders.limit.max)
  return max_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_limit::set_max(const ::std::string& value) {
  
  max_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Encoders.limit.max)
}
void Encoders_limit::set_max(const char* value) {
  
  max_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Encoders.limit.max)
}
void Encoders_limit::set_max(const char* value, size_t size) {
  
  max_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Encoders.limit.max)
}
::std::string* Encoders_limit::mutable_max() {
  
  // @@protoc_insertion_point(field_mutable:Encoders.limit.max)
  return max_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Encoders_limit::release_max() {
  // @@protoc_insertion_point(field_release:Encoders.limit.max)
  
  return max_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_limit::set_allocated_max(::std::string* max) {
  if (max != NULL) {
    
  } else {
    
  }
  max_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), max);
  // @@protoc_insertion_point(field_set_allocated:Encoders.limit.max)
}

// optional string value = 4;
void Encoders_limit::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Encoders_limit::value() const {
  // @@protoc_insertion_point(field_get:Encoders.limit.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_limit::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Encoders.limit.value)
}
void Encoders_limit::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Encoders.limit.value)
}
void Encoders_limit::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Encoders.limit.value)
}
::std::string* Encoders_limit::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:Encoders.limit.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Encoders_limit::release_value() {
  // @@protoc_insertion_point(field_release:Encoders.limit.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_limit::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:Encoders.limit.value)
}

// optional string range = 5;
void Encoders_limit::clear_range() {
  range_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Encoders_limit::range() const {
  // @@protoc_insertion_point(field_get:Encoders.limit.range)
  return range_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_limit::set_range(const ::std::string& value) {
  
  range_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Encoders.limit.range)
}
void Encoders_limit::set_range(const char* value) {
  
  range_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Encoders.limit.range)
}
void Encoders_limit::set_range(const char* value, size_t size) {
  
  range_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Encoders.limit.range)
}
::std::string* Encoders_limit::mutable_range() {
  
  // @@protoc_insertion_point(field_mutable:Encoders.limit.range)
  return range_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Encoders_limit::release_range() {
  // @@protoc_insertion_point(field_release:Encoders.limit.range)
  
  return range_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_limit::set_allocated_range(::std::string* range) {
  if (range != NULL) {
    
  } else {
    
  }
  range_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), range);
  // @@protoc_insertion_point(field_set_allocated:Encoders.limit.range)
}

inline const Encoders_limit* Encoders_limit::internal_default_instance() {
  return &Encoders_limit_default_instance_.get();
}
// -------------------------------------------------------------------

// Encoders_mediaCodec

// optional string name = 1;
void Encoders_mediaCodec::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Encoders_mediaCodec::name() const {
  // @@protoc_insertion_point(field_get:Encoders.mediaCodec.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_mediaCodec::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Encoders.mediaCodec.name)
}
void Encoders_mediaCodec::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Encoders.mediaCodec.name)
}
void Encoders_mediaCodec::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Encoders.mediaCodec.name)
}
::std::string* Encoders_mediaCodec::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Encoders.mediaCodec.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Encoders_mediaCodec::release_name() {
  // @@protoc_insertion_point(field_release:Encoders.mediaCodec.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_mediaCodec::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Encoders.mediaCodec.name)
}

// optional string type = 2;
void Encoders_mediaCodec::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Encoders_mediaCodec::type() const {
  // @@protoc_insertion_point(field_get:Encoders.mediaCodec.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_mediaCodec::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Encoders.mediaCodec.type)
}
void Encoders_mediaCodec::set_type(const char* value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Encoders.mediaCodec.type)
}
void Encoders_mediaCodec::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Encoders.mediaCodec.type)
}
::std::string* Encoders_mediaCodec::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:Encoders.mediaCodec.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Encoders_mediaCodec::release_type() {
  // @@protoc_insertion_point(field_release:Encoders.mediaCodec.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Encoders_mediaCodec::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:Encoders.mediaCodec.type)
}

// optional .Encoders.alias Alias = 3;
bool Encoders_mediaCodec::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
void Encoders_mediaCodec::clear_alias() {
  if (GetArenaNoVirtual() == NULL && alias_ != NULL) delete alias_;
  alias_ = NULL;
}
const ::Encoders_alias& Encoders_mediaCodec::alias() const {
  // @@protoc_insertion_point(field_get:Encoders.mediaCodec.Alias)
  return alias_ != NULL ? *alias_
                         : *::Encoders_alias::internal_default_instance();
}
::Encoders_alias* Encoders_mediaCodec::mutable_alias() {
  
  if (alias_ == NULL) {
    alias_ = new ::Encoders_alias;
  }
  // @@protoc_insertion_point(field_mutable:Encoders.mediaCodec.Alias)
  return alias_;
}
::Encoders_alias* Encoders_mediaCodec::release_alias() {
  // @@protoc_insertion_point(field_release:Encoders.mediaCodec.Alias)
  
  ::Encoders_alias* temp = alias_;
  alias_ = NULL;
  return temp;
}
void Encoders_mediaCodec::set_allocated_alias(::Encoders_alias* alias) {
  delete alias_;
  alias_ = alias;
  if (alias) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Encoders.mediaCodec.Alias)
}

// repeated .Encoders.limit Limit = 4;
int Encoders_mediaCodec::limit_size() const {
  return limit_.size();
}
void Encoders_mediaCodec::clear_limit() {
  limit_.Clear();
}
const ::Encoders_limit& Encoders_mediaCodec::limit(int index) const {
  // @@protoc_insertion_point(field_get:Encoders.mediaCodec.Limit)
  return limit_.Get(index);
}
::Encoders_limit* Encoders_mediaCodec::mutable_limit(int index) {
  // @@protoc_insertion_point(field_mutable:Encoders.mediaCodec.Limit)
  return limit_.Mutable(index);
}
::Encoders_limit* Encoders_mediaCodec::add_limit() {
  // @@protoc_insertion_point(field_add:Encoders.mediaCodec.Limit)
  return limit_.Add();
}
::google::protobuf::RepeatedPtrField< ::Encoders_limit >*
Encoders_mediaCodec::mutable_limit() {
  // @@protoc_insertion_point(field_mutable_list:Encoders.mediaCodec.Limit)
  return &limit_;
}
const ::google::protobuf::RepeatedPtrField< ::Encoders_limit >&
Encoders_mediaCodec::limit() const {
  // @@protoc_insertion_point(field_list:Encoders.mediaCodec.Limit)
  return limit_;
}

inline const Encoders_mediaCodec* Encoders_mediaCodec::internal_default_instance() {
  return &Encoders_mediaCodec_default_instance_.get();
}
// -------------------------------------------------------------------

// Encoders

// repeated .Encoders.mediaCodec MediaCodec = 1;
int Encoders::mediacodec_size() const {
  return mediacodec_.size();
}
void Encoders::clear_mediacodec() {
  mediacodec_.Clear();
}
const ::Encoders_mediaCodec& Encoders::mediacodec(int index) const {
  // @@protoc_insertion_point(field_get:Encoders.MediaCodec)
  return mediacodec_.Get(index);
}
::Encoders_mediaCodec* Encoders::mutable_mediacodec(int index) {
  // @@protoc_insertion_point(field_mutable:Encoders.MediaCodec)
  return mediacodec_.Mutable(index);
}
::Encoders_mediaCodec* Encoders::add_mediacodec() {
  // @@protoc_insertion_point(field_add:Encoders.MediaCodec)
  return mediacodec_.Add();
}
::google::protobuf::RepeatedPtrField< ::Encoders_mediaCodec >*
Encoders::mutable_mediacodec() {
  // @@protoc_insertion_point(field_mutable_list:Encoders.MediaCodec)
  return &mediacodec_;
}
const ::google::protobuf::RepeatedPtrField< ::Encoders_mediaCodec >&
Encoders::mediacodec() const {
  // @@protoc_insertion_point(field_list:Encoders.MediaCodec)
  return mediacodec_;
}

inline const Encoders* Encoders::internal_default_instance() {
  return &Encoders_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
